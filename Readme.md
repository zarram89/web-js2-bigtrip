# Проект «{{projectTitle}}»

* Студент: [{{userName}}]({{userProfile}}).
* Наставник: `Неизвестно`.

---

_Не удаляйте и не изменяйте папки и файлы:_
_`.editorconfig`, `.gitattributes`._

---

### Памятка

#### 1. Зарегистрируйтесь на Гитхабе

Если у вас ещё нет аккаунта на [github.com](https://github.com/join), скорее зарегистрируйтесь.

#### 2. Создайте форк

Откройте репозиторий и нажмите кнопку «Fork» в правом верхнем углу. Репозиторий из Академии будет скопирован в ваш аккаунт.

<img width="769" alt="Press 'Fork'" src="https://cloud.githubusercontent.com/assets/259739/20264045/a1ddbf40-aa7a-11e6-9a1a-724a1c0123c8.png">

Получится вот так:

<img width="769" alt="Forked" src="https://cloud.githubusercontent.com/assets/259739/20264122/f63219a6-aa7a-11e6-945a-89818fc7c014.png">

#### 3. Клонируйте репозиторий на свой компьютер

Будьте внимательны: нужно клонировать свой репозиторий (форк), а не репозиторий Академии. Также обратите внимание, что клонировать репозиторий нужно через SSH, а не через HTTPS. Нажмите зелёную кнопку в правой части экрана, чтобы скопировать SSH-адрес вашего репозитория:

<img width="769" alt="SSH" src="https://cloud.githubusercontent.com/assets/259739/20264180/42704126-aa7b-11e6-9ab4-73372b812a53.png">

Клонировать репозиторий можно так:

```
git clone SSH-адрес_вашего_форка
```

Команда клонирует репозиторий на ваш компьютер и подготовит всё необходимое для старта работы.

#### 4. Начинайте обучение!

---

<a href="https://htmlacademy.ru/intensive/ecmascript"><img align="left" width="50" height="50" title="HTML Academy" src="https://up.htmlacademy.ru/static/img/intensive/ecmascript/logo-for-github.svg"></a>

Репозиторий создан для обучения на профессиональном курсе «[JavaScript. Архитектура клиентских приложений](https://htmlacademy.ru/intensive/ecmascript)» от [HTML Academy](https://htmlacademy.ru).

[check-image]: https://github.com/htmlacademy-ecmascript/{{userId}}-{{projectName}}/workflows/Project%20check/badge.svg?branch=master
[check-url]: https://github.com/htmlacademy-ecmascript/{{userId}}-{{projectName}}/actions

---

# Техническое задание

## Проект: Большое путешествие

### О проекте
«Большое путешествие» — современный сервис для настоящих путешественников. Сервис помогает детально спланировать маршрут поездки, рассчитать стоимость путешествия и получить информацию о достопримечательностях. Минималистичный интерфейс не даст повода отвлечься и сфокусирует внимание на планировании путешествия.

### 1. Описание функциональности

#### 1.1 Общий контейнер
Новая точка маршрута создаётся нажатием на кнопку «New Event». После нажатия пользователь видит форму создания новой точки маршрута, где ему необходимо заполнить несколько полей (о полях будет рассказано позже).

#### 1.2 Маршрут поездки
Путешествие строится из отдельных точек маршрута. Точка маршрута — отдельное событие в путешествии. Точкой маршрута может быть остановка в каком-нибудь месте (Check-in, Sightseeing, Restaurant) или поездка на транспортном средстве (Taxi, Bus, Train, Ship, Drive и Flight).

Точка маршрута принадлежит к одному из типов: Taxi, Bus, Train, Ship, Drive, Flight, Check-in, Sightseeing, Restaurant.

Точки маршрута загружаются с сервера при старте приложения.

Точки маршрута по умолчанию располагаются сверху вниз от самых старых к самым новым по дате начала события вне зависимости от длительности: один день, меньше одного дня, больше одного дня.

В случае отсутствия точек маршрута вместо списка отображается текст: «Click New Event to create your first point».

#### 1.3 Точка маршрута
По умолчанию точка маршрута в списке отображается в режиме просмотра.

В колонке «Time» отображается время и продолжительность нахождения в точке маршрута (разность между окончанием и началом события). Время маршрута отображается в формате начало — окончание (например, «10:30 — 11:00»). Формат продолжительности нахождения в точке маршрута зависит от длительности:

*   Менее часа: минуты (например, 23M);
*   Менее суток: часы минуты (например, 02H 44M или 12H 00M, если минуты равны нулю);
*   Более суток: дни часы минуты (например, 51D 02H 30M или 07D 00H 00M, если часы и/или минуты равны нулю).

В колонке «Offers» отображаются дополнительные опции, выбранные для точки маршрута.

Кнопка «Favorite» (отображается в виде звёздочки). Добавляет точку маршрута в избранное. После добавления в избранное, кнопка меняет состояние — яркая звезда. Повторный клик по кнопке удаляет точку маршрута из избранного и возвращает кнопку в исходное состояние.

#### 1.4 Новая точка маршрута
Новая точка маршрута создаётся нажатием на кнопку «New Event». Форма создания новой точки маршрута появляется в самом начале списка. Кнопка при этом блокируется на время создания новой точки.

Если в момент нажатия на кнопку «New Event» был выбран фильтр или применена сортировка, то они сбрасываются на состояния «Everything» и по дате соответственно.

Нажатие кнопки «Esc» скрывает форму создания новой точки маршрута. Несохранённые изменения пропадают.

Нажатие на кнопку «New Event» закрывает открытую форму редактирования точки маршрута, если таковая была. Изменения при закрытии не сохраняются.

В форме создания новой точки маршрута пользователю доступны следующие элементы управления:

*   Кнопка «Save». Сохранение точки маршрута и закрытие формы создания точки маршрута.
*   Кнопка «Cancel». Отмена изменений и закрытие формы создания точки маршрута.

При открытии формы все поля, кроме типа точки маршрута, пусты, дополнительные опции не выбраны, значение поля «Стоимость» — 0. Предустановленный тип точки маршрута — «Flight».

Для создания новой точки маршрута пользователь заполняет:

*   Тип точки маршрута (один из: Taxi, Bus, Train, Ship, Drive, Flight, Check-in, Sightseeing, Restaurant).
*   Пункт назначения. Выбирается из списка предложенных значений, полученных с сервера. Пользователь не может ввести свой вариант для пункта назначения.
*   Дата и время начала события. Выбор времени и даты осуществляется с помощью библиотеки flatpickr.js. Выбранная дата и время отображаются в поле в формате: день/месяц/год часы:минуты (например «25/12/19 16:00»).
*   Дата и время окончания события. Формат и требования аналогичны дате начала. Дата окончания не может быть меньше даты начала события.
*   Стоимость. Целое положительное число.
*   Дополнительные опции. В зависимости от типа точки маршрута пользователь может выбрать дополнительные опции (offers).

Дополнительные опции отображаются в блоке offers. Набор дополнительных опций, которые может выбрать пользователь при создании точки маршрута, зависит от типа точки маршрута. Наборы дополнительных опций для каждого типа точки маршрута загружаются с сервера при старте приложения.

Пользователь может отметить одну или несколько дополнительных опций.

Дополнительная опция применяется к точке маршрута один раз. Повторный клик на дополнительную опцию отменяет её применение.

Список дополнительных опций доступен не для всех типов точек маршрута. Для некоторых типов точек дополнительные опции могут отсутствовать. В этом случае контейнер для вывода дополнительных опций не отрисовывается.

Выбор дополнительных опций влияет на общую стоимость путешествия. Стоимость точки маршрута, которую ввёл пользователь в соответствующее поле ввода, при этом не изменяется.

При изменении типа точки маршрута блок с дополнительными опциями перерисовывается, если у нового выбранного типа точки есть дополнительные опции.

После выбора пункта назначения появляется блок «Destination». В нём отображается информация о месте назначения (изображения, текст). Информация в блоке «Destination» всегда соответствует выбранному пункту назначения. При изменении пункта назначения информация в блоке «Destination» обновляется.

Информация для блока «Destination» загружается с сервера при старте приложения.

Если информация о пункте назначения отсутствует, блок «Destination» не отрисовывается.

Если у типа точки маршрута нет опций, и не выбрано направление точки маршрута, то блок с дополнительными опциями и описанием направления не отрисовывается.

После сохранения точка маршрута располагается в списке точек маршрута в соответствии с датой начала события по этой точке.

Если дата начала двух и более точек совпадает, расположение этих точек относительно друг друга реализуется на усмотрение разработчика.

Работа с датой и временем происходит в соответствии с часовым поясом данных, полученных от сервера.

Введённые пользователем данные экранируются.

#### 1.5 Редактирование точки маршрута
Для перехода к форме редактирования точки маршрута пользователь кликает по кнопке с изображением «Стрелка вниз» в правом углу карточки точки маршрута.

В форме редактирования пользователю доступны следующие элементы управления:

*   Кнопка «Save». Сохраняет изменения, закрывает форму редактирования.
*   Кнопка «Delete». Удаляет точку маршрута, закрывает форму редактирования.

В форме редактирования представлены все поля, которые пользователь заполняет при создании новой точки маршрута (см. раздел «Новая точка маршрута»). Правила их поведения сохраняются.

При нажатии кнопки «Esc» или кнопки с изображением «Стрелка вверх» в правом углу форма редактирования закрывается. Несохранённые изменения пропадают.

Одновременно может быть открыта только одна форма создания/редактирования.

Смена типа точки маршрута приводит к отрисовке блока с дополнительными опциями. Обратите внимание, блок с дополнительными опциями отрисовывается только при наличии опций у выбранного типа точки маршрута. Если дополнительных опций нет, блок не отрисовывается. Остальные данные, введённые пользователем, должны быть сохранены.

При смене пункта назначения блок с описанием перерисовывается; или не отрисовываются, если у пункта назначения нет описания и фотографий к нему. Остальные данные, введённые пользователем, должны быть сохранены.

Если пользователь внёс изменения в точку маршрута, не выполнил сохранение и пытается перейти к редактированию другой точки маршрута либо создать новую, то в этом случае открытая форма редактирования скрывается без сохранения изменений. После открывается другая форма редактирования или форма создания новой точки маршрута.

После сохранения изменений точка маршрута располагается в списке точек маршрута в порядке, определённом текущей сортировкой (по дате, по длительности или по стоимости).

#### 1.6 Фильтры
В приложении предусмотрено несколько фильтров:

*   Everything — полный список точек маршрута;
*   Future — список запланированных точек маршрута, т. е. точек, у которых дата начала события больше текущей даты;
*   Present — список текущих точек маршрута, т. е. точек, у которых дата начала события меньше (или равна) текущей даты, а дата окончания больше (или равна) текущей даты;
*   Past — список пройденных точек маршрута, т. е. точек у которых дата окончания маршрута меньше, чем текущая.

Выбор любого из фильтров приводит к отрисовке только тех точек маршрута, которые соответствуют выбранному фильтру.

Если в отфильтрованном списке были удалены все точки маршрута, вместо списка отображается соответствующий текст. Например, если пользователь удалил все точки маршрута из списка Past, вместо списка должна появиться заглушка «There are no past events now». Все фразы приведены в файле в директории с разметкой.

#### 1.7 Сортировка
Пользователю доступна возможность сортировки точек маршрута по стоимости (клик по заголовку колонки «Price») и длительности (клик по заголовку колонки «Time»). Сортировка работает в одном направлении — от максимального к минимальному: при сортировке по стоимости в начале списка окажутся самые дорогие точки маршрута, при сортировке по длительности — самые долгие.

Для отмены сортировки и возвращению к исходной сортировке по датам пользователь кликает по заголовку колонки «Day».

При смене фильтра сортировка сбрасывается на состояние «Day».

#### 1.8 Взаимодействие с сервером
Сервер расположен по адресу https://24.objects.htmlacademy.pro/big-trip.

Спецификация по взаимодействию с сервером в формате OpenAPI — https://24.objects.htmlacademy.pro/spec/big-trip.

В случае недоступности сервера вместо списка точек маршрута отображается сообщение: «Failed to load latest route information».

Каждый запрос к серверу должен содержать заголовок Authorization со значением Basic ${случайная строка}. Например, Basic er883jdzbdw. Случайная строка формируется однократно при старте приложения.

#### 1.9 Обратная связь интерфейса
На время загрузки, вместо списка точек маршрута, отображается сообщение: «Loading...».

При нажатии на кнопки «Save», «Delete» формируется запрос к серверу на добавление/изменение/удаление данных. На время выполнения запроса текст заголовка кнопки изменяется:

*   «Save» -> «Saving...»
*   «Delete» -> «Deleting...»

Заголовки кнопок возвращаются в исходный вид после завершения запроса.

В момент отправки запроса на создание/удаление/изменение данных по точке интерфейс блокируются от внесения изменений. Разблокировка интерфейса происходит после завершения выполнения запроса (неважно, успешно выполнен запрос или нет).

Если запрос не удалось выполнить (сервер недоступен, произошла ошибка), форма редактирования/создания остаётся открытой, к ней применяется эффект «покачивание головой». Если не удалось выполнить запрос на добавление в избранное, эффект «покачивание головой» применяется к карточке точки маршрута.

Обновление элементов (удаление точки маршрута, обновление точки маршрута и т.д) в DOM происходит только после успешного выполнения запроса к серверу.

### 2. Дополнительные задания
Обратите внимание, если вы планируете оживление наименования маршрута, дат и общей стоимости путешествия, добавьте этот блок в разметку в вашем проекте.

Наименование маршрута путешествия формируется автоматически и состоит из пунктов назначения (названий городов), разделённых тире: «Amsterdam — Geneva — Chamonix». Если городов больше 3-х, то в наименовании маршрута отображается первый и последний город, разделённые многоточием: «Amsterdam —... — Chamonix».

Даты путешествия в шапке заполняются автоматически. Дата начала всего путешествия соответствует дате начала первой точки маршрута. Дата окончания — дате завершения последней точки маршрута. Например, «18 AUG — 6 OCT».

Общая стоимость путешествия пересчитывается при создании/изменении/удалении любой точки маршрута.

Кнопка фильтра становится недоступной, если фильтру не соответствует ни одна из точек маршрута.

### 3. Разное
В зависимости от состояния, некоторым элементам управления применяются соответствующие классы оформления. Например, активный фильтр и так далее. Примеры доступны в директории с вёрсткой (markup).

---

# Задача 1 (module1-task1)

## Настройка сборки
Настройте сборку проекта так, чтобы зависимости в JS собирались при помощи сборщика модулей Webpack. Для этого выполните следующие шаги:

1.  Установите из npm пакеты webpack и webpack-cli.
2.  Создайте в корне проекта файл webpack.config.js и опишите конфигурацию сборки:
    *   задайте main.js точкой входа;
    *   в качестве директории для сборки укажите папку build. Помните, что путь должен быть абсолютный. Используйте path.resolve;
    *   файл сборки (бандл) назовите bundle.js;
    *   активируйте опцию очистки директории для сборки перед новой сборкой;
    *   активируйте генерацию source-maps.
3.  Установите из npm пакет copy-webpack-plugin. Это плагин для Webpack, который за нас будет копировать файлы из /public в /build и туда же подкладывать бандл. После установки нужно настроить плагин в webpack.config.js.
4.  Добавьте в package.json скрипт с именем build со значением webpack --mode production. С его помощью мы будем собирать Webpack'ом код для публикации проекта.
5.  Собираемые с помощью Webpack файлы не должны попасть в репозиторий, поэтому добавьте их в .gitignore.

## Настройка сервера для разработки
Чтобы на каждое изменение кодовой базы не собирать бандл и не открывать public/index.html в браузере руками, настроим сервер для разработки.

1.  Установите из npm пакет webpack-dev-server.
2.  Добавьте в package.json скрипт с именем start для запуска сервера. Значением будет команда запуска сервера и настройки: webpack serve --mode development --open.

## Настройка транспайлера
Если мы хотим в исходном коде использовать новейшие возможности JavaScript, нужно настроить Babel. Это транспайлер — инструмент, который автоматически превращает современный код в код, поддерживаемый нужными браузерами.

1.  Установите из npm основной пакет @babel/core.
2.  Установите плагин @babel/preset-env. В нём содержатся инструкции в какой поддерживаемый код можно перевести новейшие конструкции.
3.  Установите лоадер babel-loader. Он нужен, чтобы транспилировать код во время сборки.
4.  Добавьте в webpack.config.js настройки для транспилятора.
5.  Добавьте в package.json секцию browserslist с указанием браузеров, которые мы хотим поддерживать. Именно на этот список будет смотреть плагин @babel/preset-env, подбирая инструкции для транспиляции.

## Настройка хэширования
Измените имя файла сборки на bundle.[contenthash].js.

1.  Установите из npm пакет html-webpack-plugin. Это плагин, который позволит автоматически генерировать html-файлы и подключать в них актуальный файл со сборкой.
2.  Настройте плагин в webpack.config.js: укажите файл с шаблоном и, если нужно, другие опции. При необходимости добавьте index.html в исключения для copy-webpack-plugin.

## Компоненты (View) и Presenter
Первая ваша задача будет заключаться в «нарезке» вёрстки на отдельные компоненты (элементы интерфейса). Компоненты мы будем отрисовывать динамически — с помощью JavaScript. Для этого мы начнём знакомство с View и Presenter из MVP.

1.  Создайте модули (отдельные файлы) и опишите в них классы для генерации DOM-элементов. Эти модули — наши компоненты, или же View в рамках MVP.
    *   для них нужно завести отдельную директорию src/view;
    *   именуйте файлы как существительные;
    *   для экспорта классов используйте экспорт по умолчанию.
2.  На сколько компонентов и на какие именно компоненты разбить страницу решите самостоятельно, или воспользуйтесь предложенным списком:
    *   фильтры;
    *   сортировка;
    *   форма создания;
    *   форма редактирования;
    *   точка маршрута (в списке).
3.  Заведите презентер, который будет отвечать за логику отрисовки компонентов, и отрисуйте компоненты по одному экземпляру на страницу, кроме:
    *   компонент «Точка маршрута» отрисовывается в списке 3 раза;
    *   компонент «Форма редактирования» отрисовывается 1 раз, но должен располагаться первым в списке.

---

# Решение Задачи 1 (module2-task1)

Для выполнения задачи я выполнил следующие действия:

### 1. Настройка окружения
*   Установил необходимые зависимости: `webpack`, `webpack-cli`, `webpack-dev-server`, `copy-webpack-plugin`, `html-webpack-plugin`, `@babel/core`, `@babel/preset-env`, `babel-loader`, `css-loader`, `style-loader`.
*   Настроил `webpack.config.js`:
    *   Точка входа: `src/main.js`.
    *   Вывод: `build/bundle.[contenthash].js` с очисткой директории.
    *   Подключил плагины `HtmlWebpackPlugin` (для генерации HTML) и `CopyPlugin` (для копирования статики).
    *   Настроил `babel-loader` для транспиляции JS файлов.
    *   Настроил `css-loader` и `style-loader` для обработки CSS.
*   Настроил `babel.config.js` с пресетом `@babel/preset-env`.
*   Обновил `package.json`:
    *   Добавил скрипты `build` и `start`.
    *   Добавил конфигурацию `browserslist`.

### 2. Реализация MVP архитектуры
*   Создал структуру директорий: `src/view` и `src/presenter`.
*   Реализовал компоненты View (на основе предоставленной верстки):
    *   `FilterView`: отображает фильтры.
    *   `SortView`: отображает сортировку.
    *   `EventListView`: контейнер для списка событий.
    *   `PointView`: отображает карточку точки маршрута.
    *   `EditPointView`: отображает форму редактирования точки.
    *   `CreationFormView`: отображает форму создания новой точки.
*   Реализовал `BoardPresenter`:
    *   Отвечает за инициализацию и отрисовку компонентов на странице.
    *   Рендерит сортировку, список событий, форму редактирования (первым элементом) и 3 тестовые точки маршрута.
*   Настроил точку входа `src/main.js`:
    *   Инициализирует презентер и рендерит фильтры в шапку.

### 3. Проверка
*   Проект успешно собирается командой `npm run build`.
*   Сервер разработки запускается командой `npm start`, и страница корректно отображается в браузере с ожидаемыми компонентами.

---

# Задача 2: Шаблонизируй это (module2-task1)

В этом задании мы отделим данные от представления: избавимся от статического контента в шаблонах компонентов и заведём в приложении для каждой сущности подходящую структуру данных.

## Описание задачи
1.  **Структуры данных**: Определить структуры для точек маршрута, пунктов назначения и дополнительных опций.
2.  **Mock-данные**: Создать генератор случайных данных для разработки.
3.  **Model**: Создать модель (`PointsModel`), которая будет хранить и предоставлять данные.
4.  **View**: Обновить компоненты `PointView` и `EditPointView`, чтобы они принимали данные в конструктор и использовали их при генерации шаблона.
5.  **Presenter**: Обновить `BoardPresenter`, чтобы он получал данные из модели и передавал их во View.

# Решение Задачи 2 (module2-task1)

Для выполнения задачи я выполнил следующие действия:

### 1. Создание Mock-данных
*   Создал файлы в `src/mock/`:
    *   `const.js`: Константы для типов точек, городов, описаний и опций.
    *   `utils.js`: Вспомогательные функции для генерации случайных чисел и дат.
    *   `point.js`: Генераторы для точек маршрута (`generatePoint`), пунктов назначения (`generateDestination`) и опций (`generateOffersByType`).

### 2. Реализация Model
*   Создал класс `PointsModel` в `src/model/points-model.js`.
*   Модель инициализирует массив из 3 случайных точек и предоставляет метод `getPoints()`.

### 3. Обновление View
*   **`PointView`**:
    *   Конструктор теперь принимает объект точки и массив назначений.
    *   Шаблон обновлен для использования реальных данных (дата, время, тип, цена, выбранные опции).
    *   Реализовано форматирование времени и длительности (с использованием `dayjs`).
*   **`EditPointView`**:
    *   Конструктор принимает объект точки.
    *   Шаблон обновлен для отображения данных редактируемой точки (тип, город, даты, цена, доступные и выбранные опции, описание и фото назначения).

### 4. Обновление Presenter
*   **`BoardPresenter`**:
    *   Метод `init` теперь принимает `pointsModel`.
    *   Получает точки из модели.
    *   Рендерит форму редактирования для первой точки.
    *   Рендерит остальные точки в режиме просмотра.

### 5. Точка входа
*   В `src/main.js` инициализировал `PointsModel` и передал его в `boardPresenter.init`.

---

# Задача 3: Фреймворк абстракций (module3-task1)

В этом задании мы попрактикуемся в наследовании. Кексобот выделил общие части всех View в абстрактный класс. Добавил туда обновлённый render-модуль и ещё некоторые вещи на будущее.

## Описание задачи
1.  **Наследование**: Унаследовать все View от абстрактного класса `AbstractView` из фреймворка.
2.  **Рефакторинг View**: Удалить дублирующийся код (свойства `element`, методы `getElement`, `removeElement`), реализовать геттер `template`.
3.  **Обработчики событий**: Использовать методы `set...Handler` для добавления обработчиков событий внутри View.
4.  **Настоящее редактирование**: Реализовать логику замены точки маршрута на форму редактирования и обратно в `BoardPresenter`.

# Решение Задачи 3 (module3-task1)

Для выполнения задачи я выполнил следующие действия:

### 1. Рефакторинг View
*   Все компоненты View (`PointView`, `EditPointView`, `EventListView`, `SortView`, `FilterView`, `CreationFormView`) теперь наследуются от `AbstractView`.
*   Удалены методы `getElement` и `removeElement`, так как они реализованы в родительском классе.
*   Метод `getTemplate` переименован в геттер `get template()`.
*   В `PointView` добавлен метод `setEditClickHandler` для обработки клика по кнопке открытия формы.
*   В `EditPointView` добавлены методы `setFormSubmitHandler` (для сохранения) и `setRollupClickHandler` (для закрытия без сохранения).

### 2. Логика редактирования в Presenter
*   Обновил `BoardPresenter`:
    *   Теперь при инициализации рендерятся только точки маршрута (форма редактирования скрыта по умолчанию).
    *   Для каждой точки создаются экземпляры `PointView` и `EditPointView`.
    *   Реализованы функции `replacePointToForm` и `replaceFormToPoint` с использованием функции `replace` из фреймворка.
    *   Добавлен обработчик нажатия `Esc` для закрытия формы.
    *   Навешены обработчики событий на компоненты View для переключения между режимами просмотра и редактирования.

### 3. Проверка
*   Проект успешно собирается.
*   Реализована интерактивность:
    *   Клик по стрелке вниз открывает форму редактирования.
    *   Клик по кнопке "Save" или стрелке вверх закрывает форму.
    *   Нажатие `Esc` закрывает форму.

---

# Задача 4: Связывание данных и состояние пустоты (module4-task1)

В этом задании мы продолжим отделять данные от представления. Научим оставшиеся компоненты принимать данные снаружи и реализуем состояние пустого списка.

## Описание задачи
1.  **Фильтры**: Научить `FilterView` принимать данные о фильтрах и генерировать разметку динамически.
2.  **Генерация фильтров**: Создать утилиты для генерации фильтров на основе списка точек.
3.  **Пустой список**: Создать компонент `NoPointView` и отображать его, если список точек пуст.

# Решение Задачи 4 (module4-task1)

Для выполнения задачи я выполнил следующие действия:

### 1. Реализация пустого списка
*   Создал компонент `NoPointView` (`src/view/no-point-view.js`), который отображает сообщение "Click New Event to create your first point".
*   Обновил `BoardPresenter`:
    *   Теперь проверяет длину списка точек.
    *   Если список пуст, рендерит `NoPointView` вместо списка событий и сортировки.

### 2. Динамические фильтры
*   Создал утилиты фильтрации в `src/utils/filter.js`:
    *   Определил типы фильтров (`EVERYTHING`, `FUTURE`, `PRESENT`, `PAST`).
    *   Реализовал функции проверки дат (`isFuture`, `isPresent`, `isPast`).
    *   Создал объект `filter` с функциями фильтрации.
*   Создал генератор фильтров в `src/mock/filter.js`:
    *   Функция `generateFilter` принимает список точек и возвращает массив объектов фильтров с именем и количеством точек.
*   Обновил `FilterView`:
    *   Конструктор принимает массив фильтров.
    *   Шаблон генерируется динамически на основе переданных фильтров.
    *   Если количество точек для фильтра равно 0, фильтр становится `disabled`.
*   Обновил `main.js`:
    *   Генерирует фильтры на основе точек из модели.
    *   Передает сгенерированные фильтры в `FilterView`.

### 3. Проверка
*   Проект успешно собирается.
*   Фильтры отображаются корректно.
*   Если удалить все точки из модели (вернуть пустой массив), отображается сообщение-заглушка.

---

# Задача 5: Презентеры и интерактивность (module5-task1)

В этом задании мы разгрузим `BoardPresenter`, выделив логику точки маршрута в отдельный презентер, и реализуем интерактивность (добавление в избранное, открытие только одной формы редактирования).

## Описание задачи
1.  **PointPresenter**: Создать отдельный презентер для точки маршрута, который будет управлять её отрисовкой и обработчиками событий.
2.  **Частичный датабиндинг**: Реализовать обработку клика по кнопке "Favorite" с обновлением данных и перерисовкой компонента.
3.  **Только одна форма**: Реализовать логику, при которой одновременно может быть открыта только одна форма редактирования.

# Решение Задачи 5 (module5-task1)

Для выполнения задачи я выполнил следующие действия:

### 1. Создание PointPresenter
*   Создал класс `PointPresenter` в `src/presenter/point-presenter.js`.
*   Он принимает контейнер списка, функцию обновления данных (`changeData`) и функцию смены режима (`changeMode`).
*   Реализовал методы `init`, `destroy`, `resetView`.
*   Перенес логику создания компонентов `PointView` и `EditPointView`, а также обработчики событий (`replace`, `esc`, `submit`) из `BoardPresenter` в `PointPresenter`.

### 2. Обновление BoardPresenter
*   Рефакторинг `BoardPresenter`:
    *   Теперь он хранит коллекцию презентеров точек (`Map`).
    *   Метод `init` создает экземпляры `PointPresenter` для каждой точки.
    *   Реализован метод `#handlePointChange` для обновления данных точки (пока только в локальном массиве и перерисовка точки).
    *   Реализован метод `#handleModeChange` для закрытия всех открытых форм редактирования при открытии новой.
    *   Добавлен метод `#clearPointList` для очистки списка перед перерисовкой.

### 3. Интерактивность
*   **Favorite**:
    *   В `PointView` добавлен обработчик клика по кнопке "Favorite".
    *   В `PointPresenter` добавлен метод `#handleFavoriteClick`, который вызывает `changeData` с инвертированным полем `isFavorite`.
*   **Single Edit Form**:
    *   В `PointPresenter` добавлен режим (`DEFAULT`, `EDITING`).
    *   При переключении в режим редактирования вызывается `changeMode`, который уведомляет `BoardPresenter`.
    *   `BoardPresenter` вызывает `resetView` у всех презентеров, закрывая другие открытые формы.

### 4. Утилиты
*   Создал `src/utils/common.js` с функцией `updateItem` для обновления элемента в массиве.

### 5. Проверка
*   Проект собирается и работает.
*   Клик по "Favorite" меняет состояние кнопки (звезда закрашивается).
*   При открытии одной формы редактирования, другая (если была открыта) автоматически закрывается.

---

# Задача 6: Сортировка (module5-task2)

В этом задании мы научимся динамически изменять порядок отображаемых DOM-элементов.

## Описание задачи
1.  **SortView**: Обновить компонент сортировки, чтобы он отслеживал изменение типа сортировки и сообщал об этом презентеру.
2.  **Утилиты сортировки**: Реализовать функции сортировки по дате, времени и цене.
3.  **Логика сортировки**: В `BoardPresenter` реализовать сортировку списка точек перед отрисовкой.

# Решение Задачи 6 (module5-task2)

Для выполнения задачи я выполнил следующие действия:

### 1. Утилиты сортировки
*   Создал `src/utils/sort.js` с перечислением `SortType` и функциями сравнения:
    *   `sortByDay`: по дате начала (по умолчанию).
    *   `sortByTime`: по продолжительности (от большего к меньшему).
    *   `sortByPrice`: по цене (от большего к меньшему).

### 2. Обновление SortView
*   Добавил `data-sort-type` атрибуты к элементам ввода в шаблоне.
*   Реализовал метод `setSortTypeChangeHandler` для обработки кликов по элементам сортировки.
*   Обработчик предотвращает лишние перерисовки, если выбран тот же тип сортировки.

### 3. Обновление BoardPresenter
*   Добавил свойство `#currentSortType` для хранения текущего типа сортировки.
*   Добавил свойство `#sourcedBoardPoints` для хранения исходного порядка точек (для сброса сортировки).
*   Реализовал метод `#sortPoints` для сортировки массива `#boardPoints`.
*   Реализовал метод `#handleSortTypeChange`, который:
    *   Сортирует точки.
    *   Очищает список точек (`#clearPointList`).
    *   Заново отрисовывает список точек (`#renderPointList`).
*   Обновил `init`, чтобы сохранять исходный порядок точек в `#sourcedBoardPoints`.

### 4. Проверка
*   Проект собирается и работает.
*   При клике на "Price" точки сортируются по убыванию цены.
*   При клике на "Time" точки сортируются по убыванию длительности.
*   При клике на "Day" точки возвращаются к исходному порядку (по дате).
